\chapter{Zusammenfassung und Ausblick}

Diese Arbeit implementiert die auf Marken basierte Objekterkennung bzw. Verfolgung. Die Testobjekte werden mit Schwarz gefärbt und mit weißen Marken auf der Oberfläche markiert. Eine PMD-Kamera beobachtet die ganze Szene von oben und liefert direkt die 3D-Daten. Das gesamte Programm kann in zwei Teile, Lernen und Wiedererkennung, zusammengefasst werden. Im Lernprozess wird ein Fremdobjekt unter der Kamera gezeigt. Die Marken des Objekts werden von dem Programm erkannt und in einem Strukturgraph eingefügt, was die räumliche Struktur des Objekt beschreiben kann. Der Strukturgraph wird nach dem Lernen als eine VTK-Daten gespeichert. Wenn es mehr Objekte im Eingabebildstrom gibt, wird die Markenmenge für jedes Objekt zuerst segmentiert. Am Anfang der Wiedererkennungsphase werden die vorhandenen Strukturgraphen eingelesen, was als die Eingabemodelle der Wiedererkennung definiert werden. Für jedes Eingabebild werden alle Marken zuerst erkannt, genau wie es beim Lernen durchgeführt wird. Die erkannten Marken werden dann in unterschiedlichen Kandidaten des Objekts aufgeteilt. Ein Eingabemodel ist wiedererkannt, genau dann, wenn zumindest ein Kandidat existiert, der den gleichen Teilgraph zu diesem Eingabemodel erhält. Die aktuelle Orientierung und Lage des Objekt kann danach durch die Korrespondenzpunktepaare bestimmt werden. 

\section{Verbesserungen}
In dieser Arbeit werden viele vorhandene Ideen und Algorithmen verwendet. Bezüglich dieser Vorkenntnisse werden weiterhin viele Verbesserungen gemacht, z.B. die Helligkeitssteuerung, das neue Singulärwertzerlegungsverfahren und die Bildsteuerung usw.. Dadurch können die Ergebnisse des Lernens und der Wiedererkennung stabiler und schneller erhalten werden. Trotzdem gibt es auch einigen Probleme in der Realisierung. 

\section{Problem}
Die existierenden Problems können in zwei Bereichen, Stabilität und Zeitaufwand, zusammengefasst werden.

\subsection{Stabilität}
Die Größe und Position der Marken muss exakt entworfen werden, damit die richtigen Erkennungsergebnisse erhalten werden können. Sonst ist das Objekt schwierig zu erkennen. Aus diesem Grund sind die Lange bzw. die Breite des Objekts stark beschränkt. Die Anordnung der Marken beeinflusst auch die Quote der erfolgreichen Erkennungen in der Wiedererkennungsphase. 

\subsection{Zeitaufwand}
Wie was in Tabellen~\ref{LZ} bis \ref{22} gezeigt, erfüllt der Zeitaufwand aber nur teilweise die Echtzeitbedingung. In der Lernphase kann das Programm aber nur die Framerate bis zu 18.6 fps erreichen. In der Wiedererkennungsphase hängt die Framerate von der Anzahl der betrachteten Eingabeobjekt und Eingabemodel ab. Wenn es nur einen Eingabemodel betrachtet wird, kann das Programm im Durchschnitt 30 Bilder pro Sekunde bearbeiten. Für zwei Eingabemodel wird diese Zahl aber leider sofort auf 20 sinken. 

\section{Mögliche Lösungsverfahren}
Entweder die Stabilität oder der Zeitaufwand hängt stark von dem Detektor ab. Deshalb ist Verwendung einer neuen, besseren Detektor eine Möglichkeit, um die vorherigen Problems zu lösen. Dieser Detektor soll bessere Genauigkeit und Stabilität haben. Auf dem idealen Fall sollen alle Marken eindeutlich erkannt werden können, und die Ergebnisse unabhängig von der Helligkeit der Eingabebilder sein. Dadurch kann die Anzahl der Schleifen in Helligkeitssteuerung stark reduziert und die Kombination der Merkmalen in Markenerkennung sogar komplett entfernt werden. Diese Vereinfachungen des Programm können mehr als die Hälfte der gesamten Laufzeit sparen, was in dem Kreisdiagramm in Abbildung~\ref{LZP} deutlich gezeigt wird. Die bessere Stabilität des Detektors fordert an, dass die Erkennungsergebnisse nicht empfindlich für die Abstände zwischen den Marken sein sollen. Damit können die Marken nicht genau mit den Regeln vom Abschnitt~\ref{Ma} angebracht werden.
\\
\\
Außerdem ist die Umschreibung des Programm mit CUDA die andere Möglichkeit zur Abnahme der Laufzeit, wegen der stärkeren Berechnungsfähigkeit über die Gleitkommazahl der GPU. 


%Das zweite Beschleunigungsverfahren ist gleich wie Vorher: ein besserer Markendetektor zu finden. Das Kreisdiagramm~\ref{LZP} zeigt deutlich, dass die Teilprogramme ,,CenSurE Detektor und Helligkeitssteuerung'' und ,,Markenerkennung'' mehr als Halb der gesamten Laufzeit brauchen. Diese beide Teile hängen von dem Markendetektor stark ab. Wenn ein besserer Detektor verwendet wird, kann die Anzahl der Schleifen in Helligkeitssteuerung stark reduziert. Die Kombination der Merkmalen in Markenerkennung, die der 1 zu 1 Korrespondenz zwischen der durch Detektor erkannten Merkmale und der realen Marken anpasst, kann aber auch komplett entfernt. Diese Vereinfachung der Programms können die Laufzeit erfolgreich erniedrigen.    

%Die Oberflächen der Zielobjekt werden mit retroreflektierenden Marker markiert.  Die totale Laufzeit kann in zwei Phasen zusammengefasst werden. In der Initialisierungsphase wird die Fremdobjekt unter der Kamera gezeigt und die Marker darauf sollen herausgekannt und im System gespeichert werden. Wenn es mehr Objekte gibt, wird eine Kalibrierung am Anfang durchgeführt. Mills in \cite{MN00} hat eine kompakte Segmentierung der Bewegung mithilfe des sogenannten \glqq Feature Interval Graph\grqq  dargestellt. \cite{AJ05} erweitert die Arbeit von Mills. Ein auf Pyramide basiertes Clustering-Verfahren wird statt des alten auf Dreiecke basierten Clustering-Verfahren vorgeschlagen. Nach der Initialisierungsphase wird das Objekt aus dem Gesichtsfeld der Kamera verschoben. Die Erkennungsphase fängt genau an, wenn das gleiche Objekt wieder unter der Kamera eingebracht wird. Die reflektierende Marker sollen nochmal gesammelt werden und ein von \cite{AJ05} repräsentierter Teilgraph-Tracker wird dann implementiert, um die Objekt zu kennen und die Position zu bestimmen.         
